# 3D游戏：二、离散仿真引擎基础
## 1.简答题
### 解释游戏对象（*GameObjects*）和资源（*Assets*）的区别与联系。
游戏对象是一个能够容纳实现实际功能的组件，而资源指游戏中需要的资源，包括模型、声音文件、贴图文件等。

资源可以作为模板，实例化后得到游戏对象，或作为游戏对象中的某种属性，被多个游戏对象同时运用。

### 下载几个游戏案例，分别总结资源、对象组织的结构（指资源的目录组织结构与游戏对象树的层次结构）
资源的目录组织结构：包括预制、脚本等，并将其按照文件的类型分配到不同的文件夹以便管理。

游戏对象树的层次结构：包括游戏环境的设置（如摄像机，开始位置，场景布局）、游戏的控制、玩家以及目标等。

### 编写一个代码，使用 debug 语句来验证 MonoBehaviour 基本行为或事件触发的条件 
- 基本行为包括 Awake() Start() Update() FixedUpdate() LateUpdate()
- 常用事件包括 OnGUI() OnDisable() OnEnable()
```c
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    void Awake()
    {
        Debug.Log("Awake");
    }

    // Start is called before the first frame update
    void Start()
    {
        Debug.Log("Start");
    }

    // Update is called once per frame
    void Update()
    {
        Debug.Log("Update");
    }

    void FixedUpdate()
    {
        Debug.Log("FixedUpdate");
    }

    void LateUpdate()
    {
        Debug.Log("LateUpdate");
    }

    void OnGUI()
    {
        Debug.Log("OnGUI");
    }
    void OnDisable()
    {
        Debug.Log("OnDisable");
    }
    void OnEnable()
    {
        Debug.Log("OnEnable");
    }
}
```
运行后 Console 输出如下：


可知：  
- Awake()：在脚本对象实例化时被调用；  
- Start()：在对象的第一帧时被调用，且在Update()之前；  
- Update()：当MonoBehaviour启用时，在每一帧被调用，用于更新，每一帧的时间不固定；  
- FixedUpdate()： 与Update()类似，但每帧与每帧之间相差的时间固定；  
- LateUpdate()：在所有Update函数调用后被调用，可用于调整脚本执行顺序；  
- OnGUI()：通过代码驱动的GUI系统，主要用来渲染和处理GUI事件，如创建调试工具、自定义属性面板、新的Editor窗口和工具等；  
- OnDisable()：当对象变为不可用或非激活状态时被调用；  
- OnEnable()：当对象变为可用或激活状态时被调用。 


### 查找脚本手册，了解 GameObject，Transform，Component 对象 
- 分别翻译官方对三个对象的描述（*Description*）  
GameObject：是Unity场景里面所有实体的基类；  
Transform：物体的位置、旋转和缩放；  
Component：一切附加到游戏物体的基类。


- 描述下图中 table 对象（实体）的属性、table 的 Transform 的属性、 table 的部件 
    - 本题目要求是把可视化图形编程界面与 Unity API 对应起来，当你在 Inspector 面板上每一个内容，应该知道对应 API。
    - 例如：table 的对象是 GameObject，第一个选择框是 activeSelf 属性。  
    ![](https://pmlpml.gitee.io/game-unity/post/images/ch02/ch02-prefabs.png)
    第一个选择框是activeSelf，用于定义对象的名称，动静态等属性；  
    第二个选择框是Transform，用于定义对象的位置、旋转、缩放；  
    第三个选择框是Box Collider，用于调整坐标系的位置、大小；  
    第四个选择框是Add Component，用于给对象添加事件。

- 用 UML 图描述 三者的关系（请使用 UMLet 14.1.1 stand-alone版本出图）
![]()

### 资源预设（*Prefabs*）与 对象克隆 (*clone*) 
- 预设（*Prefabs*）有什么好处？  
可以被置入多个场景中，也可以在一个场景中多次置入，只要Prefabs原型发生改变，所有的Prefabs实例都会产生变化，方便开发。  

- 预设与对象克隆 (*clone or copy or Instantiate of Unity Object*) 关系？  
预设是一种资源类型,可被重复使用的游戏对象；克隆是将已经存在的游戏对象，或者是资源当中的预设进行复制。  
预设中的属性改变时，由预设产生的实例也会相应的改变；而通过对象克隆出来的对象，不会因为本体的改变而改变。  
预设是克隆的一个基础步骤。

- 制作 table 预制，写一段代码将 table 预制资源实例化成游戏对象  
1.将table拉到Assets文件夹中创建预制；  
    2.创建C# Scrip文件，代码如下：
    ```c
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class NewBehaviourScript : MonoBehaviour
    {
        public GameObject prefab;

        // Use this for initialization
        void Start()
        {
            Instantiate(prefab, new Vector3(0f, 0f, 0f), Quaternion.identity);
        }
    }
    ```
    3.创建Empty Object，将代码文件应用在Empty Object上，然后将Table拉到Preb。

## 2、编程实践：小游戏
- 游戏内容： 井字棋 或 贷款计算器 或 简单计算器 等等  
- 技术限制： 仅允许使用 IMGUI 构建 UI  
- 作业目的： 
    - 了解 OnGUI() 事件，提升 debug 能力
    - 提升阅读 API 文档能力  

### 井字棋：  
#### 1. 用一个3*3二维数组创建棋盘，并将数组的初始值设定为0，声明变量empty记录剩余棋格，turn记录轮到哪一方下。函数reset用来初始化参数，在脚本被调用时（Start）执行一次。
``` c
    private int empty = 9;
    private int turn = 1;
    private int[,] chess = new int[3, 3];
    public Texture2D img;//背景图片
    public Texture2D img1;//Player1图片
    public Texture2D img2;//Player2图片

    void Start()
    {
        reset();
    }

    void reset()
    {
        empty = 9;
        turn = 1;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)         
                chess[i, j] = 0;          
        }
    }
```

#### 2. 通过OnGUI的方法每一帧都动态生成3*3的按钮形成棋盘，并且生成按钮与3*3的state数组一一对应的。如果游戏开始，当chess[i][j]值为0且按钮被点击，轮到O方，将此位置的值设为1，轮到X方，则将值设为2。当result=1时为O赢，=2时为X赢，=3为平局。

``` c
   private void OnGUI()
    {
        //改变GUI样式
        GUIStyle fontStyle = new GUIStyle();
        GUIStyle fontStyle1 = new GUIStyle();

        fontStyle.normal.background = img;
        fontStyle1.fontSize = 40;
        fontStyle1.normal.textColor = new Color(255, 255, 255);

        GUI.Label(new Rect(0, 0, 1500, 900),"", fontStyle);
        GUI.Label(new Rect(200, 100, 150, 150), img1);
        GUI.Label(new Rect(1000, 100, 150, 150), img2);

        if (GUI.Button(new Rect(550, 400, 200, 80), "Reset"))
        {
            reset();
        }

        int result = is_win();

        if (result == 1)
        {
            GUI.Label(new Rect(200, 250, 200, 50), "You win！", fontStyle1);
        }

        else if (result == 2)
        {
            GUI.Label(new Rect(1000, 250, 200, 50), "You win！", fontStyle1);
        }

        else if (result == 3)
        {
            GUI.Label(new Rect(550, 20, 200, 50), "no one wins", fontStyle1);
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (chess[i, j] == 1) GUI.Button(new Rect(i * 100 + 500, j * 100 + 80, 100, 100), img1);
                if (chess[i, j] == 2) GUI.Button(new Rect(i * 100 + 500, j * 100 + 80, 100, 100), img2);
                if (GUI.Button(new Rect(i * 100 + 500, j * 100 + 80, 100, 100), ""))
                {
                    if (result == 0)
                    {
                        if (turn == 1) chess[i, j] = 1;
                        if (turn == 2) chess[i, j] = 2;
                        empty--;

                        if (empty % 2 == 1)
                        {
                            turn = 1;
                        }

                        else
                        {
                            turn = 2;
                        }
                    }
                }
            }
        }
    }
```

#### 3. 判断游戏是否结束：

``` c
    int is_win()
    {
        int temp = chess[1, 1];
        if (temp != 0)
        {
            if (temp == chess[0, 0] && temp == chess[2, 2])
            {
                return temp;
            }

            if (temp == chess[0, 2] && temp == chess[2, 0])
            {
                return temp;
            }

            if (temp == chess[0, 1] && temp == chess[2, 1])
            {
                return temp;
            }

            if (temp == chess[1, 0] && temp == chess[1, 2])
            {
                return temp;
            }
        }

        //判断是否中心的十字形或者X字形
        temp = chess[0, 0];

        if (temp != 0)
        {
            if (temp == chess[0, 1] && temp == chess[0, 2])
            {
                return temp;
            }

            if (temp == chess[1, 0] && temp == chess[2, 0])
            {
                return temp;
            }
        }

        //判断是否是第一行或者第一列相同
        temp = chess[2, 2];

        if (temp != 0)
        {
            if (temp == chess[2, 0] && temp == chess[2, 1])
            {
                return temp;
            }

            if (temp == chess[0, 2] && temp == chess[1, 2])
            {
                return temp;
            }
        }

        //判断是否是第三行或者第三列相同
        if (empty == 0)
        {
            return 3;//没有空的地方，因此双方平局
        }

        else
        {
            return 0;//还未分出胜负
        }
    }
}
```
运行结果如下：
![]()
    